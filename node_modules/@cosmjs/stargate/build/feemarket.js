"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDynamicGasPriceConfig = isDynamicGasPriceConfig;
exports.multiplyDecimalByNumber = multiplyDecimalByNumber;
exports.checkDynamicGasPriceSupport = checkDynamicGasPriceSupport;
exports.queryDynamicGasPrice = queryDynamicGasPrice;
/* eslint-disable @typescript-eslint/no-use-before-define, no-bitwise */
const math_1 = require("@cosmjs/math");
const binary_1 = require("cosmjs-types/binary");
const utils_1 = require("./queryclient/utils");
function isDynamicGasPriceConfig(config) {
    return "minGasPrice" in config;
}
/**
 * Multiplies a Decimal by a number multiplier.
 * This is needed because Decimal.multiply() only accepts integers.
 *
 * Uses decimal arithmetic to avoid floating point precision issues.
 */
function multiplyDecimalByNumber(value, multiplier, fractionalDigits) {
    // Normalize value to target fractional digits
    const normalizedValue = value.adjustFractionalDigits(fractionalDigits);
    // Convert multiplier to Decimal with same fractional digits
    const multiplierDecimal = math_1.Decimal.fromUserInput(multiplier.toString(), fractionalDigits);
    // Multiply: (value * multiplier) / 10^fractionalDigits
    const factor = BigInt(10) ** BigInt(fractionalDigits);
    const product = (BigInt(normalizedValue.atomics) * BigInt(multiplierDecimal.atomics)) / factor;
    return math_1.Decimal.fromAtomics(product, fractionalDigits);
}
/**
 * Determines if a chain ID corresponds to an Osmosis chain.
 *
 * Matches: osmosis-{n}, osmo-test-{n}, osmosis{suffix} (e.g. osmosislocal).
 */
function isOsmosisChain(chainId) {
    const lowerChainId = chainId.toLowerCase();
    return (/^osmosis-\d+$/.test(lowerChainId) ||
        /^osmo-test-\d+$/.test(lowerChainId) ||
        /^osmosis[a-z]+$/.test(lowerChainId));
}
/**
 * Checks if a chain supports dynamic gas pricing by querying feemarket endpoints.
 *
 * This is intended for optional verification during initialization or debugging, not for
 * automatic checks before every transaction. The implementation trusts user configuration
 * and handles failures gracefully by falling back to minGasPrice.
 */
async function checkDynamicGasPriceSupport(queryClient, gasPriceDenom, chainId) {
    // Try Osmosis endpoint first if chain ID suggests Osmosis
    if (isOsmosisChain(chainId)) {
        try {
            await queryClient.queryAbci("/osmosis.txfees.v1beta1.Query/GetEipBaseFee", new Uint8Array(0));
            return true;
        }
        catch {
            // If Osmosis endpoint fails, try Skip feemarket as fallback
        }
    }
    // Try Skip feemarket endpoint
    try {
        await queryClient.queryAbci("/feemarket.feemarket.v1.Query/GasPrices", GasPricesRequest.encode({ denom: gasPriceDenom }));
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Queries the dynamic gas price from either Osmosis EIP-1559 or Skip's feemarket module.
 */
async function queryDynamicGasPrice(queryClient, gasPriceDenom, chainId) {
    if (isOsmosisChain(chainId)) {
        // Osmosis EIP-1559: GetEipBaseFee returns DecProto { dec: string }
        const response = await queryClient.queryAbci("/osmosis.txfees.v1beta1.Query/GetEipBaseFee", new Uint8Array(0));
        return DecProto.decode(response.value);
    }
    else {
        // Skip feemarket: GasPrices returns GasPricesResponse { prices: [DecCoin] }
        const response = await queryClient.queryAbci("/feemarket.feemarket.v1.Query/GasPrices", GasPricesRequest.encode({ denom: gasPriceDenom }));
        return GasPricesResponse.decode(response.value);
    }
}
// Minimal protobuf type definitions matching cosmjs-types pattern
// These are not available in cosmjs-types, so we define them here
/** Osmosis DecProto message */
// eslint-disable-next-line @typescript-eslint/naming-convention
const DecProto = {
    decode(input) {
        const reader = new binary_1.BinaryReader(input);
        let dec = "";
        while (reader.pos < reader.len) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    dec = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        if (!dec) {
            throw new Error("DecProto: dec field not found");
        }
        return (0, utils_1.decodeCosmosSdkDecFromProto)(dec);
    },
};
/** Skip feemarket GasPricesRequest message */
// eslint-disable-next-line @typescript-eslint/naming-convention
const GasPricesRequest = {
    encode(message) {
        const writer = new binary_1.BinaryWriter();
        if (message.denom) {
            writer.uint32(10).string(message.denom);
        }
        return writer.finish();
    },
};
// eslint-disable-next-line @typescript-eslint/naming-convention
const DecCoin = {
    decode(input) {
        const reader = new binary_1.BinaryReader(input);
        const message = { denom: "", amount: "" };
        while (reader.pos < reader.len) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    message.denom = reader.string();
                    break;
                case 2:
                    message.amount = reader.string();
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        return message;
    },
};
/** Skip feemarket GasPricesResponse message */
// eslint-disable-next-line @typescript-eslint/naming-convention
const GasPricesResponse = {
    decode(input) {
        const reader = new binary_1.BinaryReader(input);
        let decCoin;
        while (reader.pos < reader.len) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    // prices field (repeated DecCoin) - we only need the first one
                    decCoin = DecCoin.decode(reader.bytes());
                    break;
                default:
                    reader.skipType(tag & 7);
                    break;
            }
        }
        if (!decCoin?.amount) {
            throw new Error("GasPricesResponse: amount not found");
        }
        return (0, utils_1.decodeCosmosSdkDecFromProto)(decCoin.amount);
    },
};
//# sourceMappingURL=feemarket.js.map