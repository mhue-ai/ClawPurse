import { Uint32, Uint53, Uint64 } from "./integers";
/**
 * A type for arbitrary precision, non-negative decimals.
 *
 * Instances of this class are immutable.
 */
export declare class Decimal {
    static fromUserInput(input: string, fractionalDigits: number): Decimal;
    /**
     * Constructs a decimal given the atomic units and the fractional digits.
     *
     * Atomics units are the smallest unit you operate with.
     * E.g. for EUR this could be Euro cents and for BTC this would be Satishi.
     *
     * To create the decimal value 12.60 (EUR) you would use atomics=1260, fractionalDigits=2.
     * To create the decimal value 3.4 (BTC) you would use atomics=340000000, fractionalDigits=8.
     *
     * In order to perform arithmetic operations on Decimal, all values must have the same `fractionalDigits` value.
     * So this should be fixed once per currency, not different per value.
     */
    static fromAtomics(atomics: string | bigint, fractionalDigits: number): Decimal;
    /**
     * Creates a Decimal with value 0.0 and the given number of fractional digits.
     *
     * Fractional digits are not relevant for the value but needed to be able
     * to perform arithmetic operations with other decimals.
     */
    static zero(fractionalDigits: number): Decimal;
    /**
     * Creates a Decimal with value 1.0 and the given number of fractional digits.
     *
     * Fractional digits are not relevant for the value but needed to be able
     * to perform arithmetic operations with other decimals.
     */
    static one(fractionalDigits: number): Decimal;
    private static verifyFractionalDigits;
    static compare(a: Decimal, b: Decimal): number;
    get atomics(): string;
    get fractionalDigits(): number;
    private readonly data;
    private constructor();
    /** Creates a new instance with the same value */
    private clone;
    /** Returns the greatest decimal <= this which has no fractional part (rounding down) */
    floor(): Decimal;
    /** Returns the smallest decimal >= this which has no fractional part (rounding up) */
    ceil(): Decimal;
    /**
     * Creates a new Decimal with the same value using the new fractional digits.
     * Roughly speaking this can expand an 3.24 to 3.24000 or shrink a 5.4321 to 5.4.
     *
     * This allows you to perform arithmetic operations given two decimals
     * with different fractional digits by normalizing them.
     *
     * When new fractional digits is smaller than the original value, the amount
     * is truncated (not rounded!).
     */
    adjustFractionalDigits(newFractionalDigits: number): Decimal;
    toString(): string;
    /**
     * Returns an approximation as a float type. Only use this if no
     * exact calculation is required.
     */
    toFloatApproximation(): number;
    /**
     * a.plus(b) returns a+b.
     *
     * Both values need to have the same fractional digits.
     */
    plus(b: Decimal): Decimal;
    /**
     * a.minus(b) returns a-b.
     *
     * Both values need to have the same fractional digits.
     * The resulting difference needs to be non-negative.
     */
    minus(b: Decimal): Decimal;
    /**
     * a.multiply(b) returns a*b.
     *
     * We only allow multiplication by unsigned integers to avoid rounding errors.
     */
    multiply(b: Uint32 | Uint53 | Uint64): Decimal;
    /** Negates the value */
    neg(): Decimal;
    /** Returns the absolute value */
    abs(): Decimal;
    equals(b: Decimal): boolean;
    /**
     * Returns true if and only if value is < 0.
     *
     * Please note that in contrast to numbers, -0 cannot be represented. I.e.
     * an input of "-0" is always normalized to "0" and is non-negative.
     */
    isNegative(): boolean;
    isLessThan(b: Decimal): boolean;
    isLessThanOrEqual(b: Decimal): boolean;
    isGreaterThan(b: Decimal): boolean;
    isGreaterThanOrEqual(b: Decimal): boolean;
}
