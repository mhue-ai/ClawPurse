"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DirectEthSecp256k1HdWallet = void 0;
const amino_1 = require("@cosmjs/amino");
const crypto_1 = require("@cosmjs/crypto");
const encoding_1 = require("@cosmjs/encoding");
const signing_1 = require("./signing");
const defaultOptions = {
    bip39Password: "",
    hdPaths: [
        [
            crypto_1.Slip10RawIndex.hardened(44),
            crypto_1.Slip10RawIndex.hardened(60),
            crypto_1.Slip10RawIndex.hardened(0),
            crypto_1.Slip10RawIndex.normal(0),
            crypto_1.Slip10RawIndex.normal(0),
        ],
    ],
    prefix: "cosmos",
};
/** A wallet for protobuf based signing using SIGN_MODE_DIRECT */
class DirectEthSecp256k1HdWallet {
    /**
     * Restores a wallet from the given BIP39 mnemonic.
     *
     * @param mnemonic Any valid English mnemonic.
     * @param options An optional `DirectEthSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */
    static async fromMnemonic(mnemonic, options = {}) {
        const mnemonicChecked = new crypto_1.EnglishMnemonic(mnemonic);
        const seed = await crypto_1.Bip39.mnemonicToSeed(mnemonicChecked, options.bip39Password);
        return new DirectEthSecp256k1HdWallet(mnemonicChecked, {
            ...options,
            seed: seed,
        });
    }
    /**
     * Generates a new wallet with a BIP39 mnemonic of the given length.
     *
     * @param length The number of words in the mnemonic (12, 15, 18, 21 or 24).
     * @param options An optional `DirectSecp256k1HdWalletOptions` object optionally containing a bip39Password, hdPaths, and prefix.
     */
    static async generate(length = 12, options = {}) {
        const entropyLength = 4 * Math.floor((11 * length) / 33);
        const entropy = crypto_1.Random.getBytes(entropyLength);
        const mnemonic = crypto_1.Bip39.encode(entropy);
        return DirectEthSecp256k1HdWallet.fromMnemonic(mnemonic.toString(), options);
    }
    /** Base secret */
    secret;
    /** BIP39 seed */
    seed;
    /** Derivation instructions */
    accounts;
    constructor(mnemonic, options) {
        const prefix = options.prefix ?? defaultOptions.prefix;
        const hdPaths = options.hdPaths ?? defaultOptions.hdPaths;
        this.secret = mnemonic;
        this.seed = options.seed;
        this.accounts = hdPaths.map((hdPath) => ({
            hdPath: hdPath,
            prefix: prefix,
        }));
    }
    get mnemonic() {
        return this.secret.toString();
    }
    async getAccounts() {
        const accountsWithPrivkeys = await this.getAccountsWithPrivkeys();
        return accountsWithPrivkeys.map(({ algo, pubkey, address }) => ({
            algo: algo,
            pubkey: pubkey,
            address: address,
        }));
    }
    async signDirect(signerAddress, signDoc) {
        const accounts = await this.getAccountsWithPrivkeys();
        const account = accounts.find(({ address }) => address === signerAddress);
        if (account === undefined) {
            throw new Error(`Address ${signerAddress} not found in wallet`);
        }
        const { privkey, pubkey } = account;
        const signBytes = (0, signing_1.makeSignBytes)(signDoc);
        const hashedMessage = (0, crypto_1.keccak256)(signBytes);
        const signature = crypto_1.Secp256k1.createSignature(hashedMessage, privkey);
        const signatureBytes = new Uint8Array([...signature.r(32), ...signature.s(32)]);
        const stdSignature = (0, amino_1.encodeEthSecp256k1Signature)(pubkey, signatureBytes);
        return {
            signed: signDoc,
            signature: stdSignature,
        };
    }
    async getKeyPair(hdPath) {
        const { privkey } = crypto_1.Slip10.derivePath(crypto_1.Slip10Curve.Secp256k1, this.seed, hdPath);
        const { pubkey } = crypto_1.Secp256k1.makeKeypair(privkey);
        return {
            privkey: privkey,
            pubkey: crypto_1.Secp256k1.compressPubkey(pubkey),
        };
    }
    async getAccountsWithPrivkeys() {
        return Promise.all(this.accounts.map(async ({ hdPath, prefix }) => {
            const { privkey, pubkey } = await this.getKeyPair(hdPath);
            const address = (0, encoding_1.toBech32)(prefix, (0, amino_1.rawEthSecp256k1PubkeyToRawAddress)(pubkey));
            return {
                algo: "eth_secp256k1",
                privkey: privkey,
                pubkey: pubkey,
                address: address,
            };
        }));
    }
}
exports.DirectEthSecp256k1HdWallet = DirectEthSecp256k1HdWallet;
//# sourceMappingURL=directethsecp256k1hdwallet.js.map